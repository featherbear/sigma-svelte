{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../lib/sigma.require.js","../../lib/plugins/sigma.parsers.gexf.min.js","../../src/Sigma.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value' || descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group) {\n    const value = [];\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.push(group[i].__value);\n    }\n    return value;\n}\nfunction to_number(value) {\n    return value === '' ? undefined : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j];\n                if (attributes[attribute.name]) {\n                    j++;\n                }\n                else {\n                    node.removeAttribute(attribute.name);\n                }\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    if (value != null || input.value) {\n        input.value = value;\n    }\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    const z_index = (parseInt(computed_style.zIndex) || 0) - 1;\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +\n        `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    let unsubscribe;\n    if (is_crossorigin()) {\n        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        detach(iframe);\n        if (unsubscribe)\n            unsubscribe();\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(html, anchor = null) {\n        this.e = element('div');\n        this.a = anchor;\n        this.u(html);\n    }\n    m(target, anchor = null) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(target, this.n[i], anchor);\n        }\n        this.t = target;\n    }\n    u(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    p(html) {\n        this.d();\n        this.u(html);\n        this.m(this.t, this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error(`Function called outside component initialization`);\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next, lookup.has(block.key));\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error(`Cannot have duplicate keys in a keyed each`);\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += \" \" + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += \" \" + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : ``;\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if ($$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set() {\n            // overridden by instance, if it has props\n        }\n    };\n}\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set() {\n        // overridden by instance, if it has props\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.21.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev(\"SvelteDOMInsert\", { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev(\"SvelteDOMRemove\", { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? [\"capture\"] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev(\"SvelteDOMAddEventListener\", { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev(\"SvelteDOMRemoveEventListener\", { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev(\"SvelteDOMRemoveAttribute\", { node, attribute });\n    else\n        dispatch_dev(\"SvelteDOMSetAttribute\", { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev(\"SvelteDOMSetProperty\", { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev(\"SvelteDOMSetDataset\", { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev(\"SvelteDOMSetData\", { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(`'target' is a required option`);\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn(`Component was already destroyed`); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error(`Infinite loop detected`);\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n",";(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  // Deal with resize.  skip this for node.js apps\n  if (typeof window != 'undefined')\n    window.addEventListener('resize', function() {\n      for (var key in __instances) {\n        if (__instances.hasOwnProperty(key)) {\n          var instance = __instances[key];\n          instance.refresh();\n        }\n      }\n    });\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grapĥ with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'hovers',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.dispatchEvent('coordinatesUpdated');\n      self.renderCamera(camera);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'hovers',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph, {\n          prefix: c.readPrefix,\n          maxLevel: c.settings('nodeQuadtreeMaxLevel'),\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          (c.settings('enableEdgeHovering') ||\n            c.settings('edgesClippingWithNodes'))\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            maxLevel: c.settings('edgeQuadtreeMaxLevel'),\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var l,\n        i,\n        prefix = 0;\n\n    // Call each renderer:\n    for (i in this.renderers)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[i].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + this.renderers[i] +\n              '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[i].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"'+ a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"'+a[i].id +'\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.5.2';\n\n\n  /**\n   * Disable ES6 features if true:\n   */\n  sigma.forceES5 = false;\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n\n/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exists or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every jobs that are stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n\n// Hardcoded export for the node.js version:\nvar sigma = this.sigma,\n    conrad = this.conrad;\n\nsigma.conrad = conrad;\n\n// Dirty polyfills to permit sigma usage in node\nif (typeof HTMLElement === 'undefined')\n  HTMLElement = function() {};\n\nif (typeof window === 'undefined')\n  window = {\n    addEventListener: function() {}\n  };\n\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports)\n    exports = module.exports = sigma;\n  exports.sigma = sigma;\n}\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n\n\n  /**\n   * SigmaMap wraps an ES6 Object. Methods set, get, has, forEach, delete, and clear\n   * have the same signature than the corresponding Map methods.\n   */\n  function SigmaMap() {\n    var self = this;\n    var _store;\n\n    if (!sigma.forceES5 &&\n      typeof Map !== 'undefined' &&\n      Map.prototype.keys !== undefined &&\n      Map.prototype.forEach !== undefined\n      && Array.from !== undefined) {\n\n      _store = new Map();\n\n      Object.defineProperty(this, 'size', {\n        get: function() { return _store.size; },\n        set: undefined,\n        enumerable: true\n      });\n\n      this.set = function(key, value) { _store.set('' + key, value); };\n      this.get = function(key) { return _store.get('' + key); };\n      this.has = function(key) { return _store.has('' + key); };\n      this.forEach = function(func) { return _store.forEach(func); };\n      this.delete = function(key) { return _store.delete('' + key); };\n      this.clear = function() { _store.clear(); };\n\n      this.keyList = function () {\n        return Array.from(_store.keys());\n      };\n\n      this.valueList = function () {\n        var values = [];\n        _store.forEach(function(val) {\n          values.push(val);\n        });\n        return values;\n      };\n    }\n    else {\n      _store = Object.create(null);\n      this.size = 0;\n\n      this.keyList = function () {\n        return Object.keys(_store).filter(function(key) {\n          return _store[key] !== undefined;\n        });\n      };\n\n      this.valueList = function () {\n        var keys = Object.keys(_store);\n        var values = [];\n\n        for (var i = 0; i < keys.length; i++) {\n          var val = _store[keys[i]];\n          if (val !== undefined) {\n            values.push(val);\n          }\n        }\n        return values;\n      };\n\n      this.set = function (key, value) {\n        if (_store[key] === undefined) self.size++;\n\n        _store[key] = value;\n      };\n\n      this.get = function (key) {\n        return _store[key];\n      };\n\n      this.has = function (key) {\n        return _store[key] !== undefined;\n      };\n\n      this.forEach = function (func) {\n        var keys = Object.keys(_store);\n        for (var i = 0; i < keys.length; ++i) {\n          var key = keys[i],\n              obj = _store[key];\n\n          if (typeof obj !== 'undefined') {\n            func(obj, key);\n          }\n        }\n      };\n\n      this.delete = function (key) {\n        var value = _store[key];\n        _store[key] = undefined;\n\n        if (value !== undefined) self.size--;\n\n        return value;\n      };\n\n      this.clear = function () {\n        for (var k in _store)\n          if (!('hasOwnProperty' in _store) || _store.hasOwnProperty(k))\n            delete _store[k];\n\n        _store = Object.create(null);\n        self.size = 0;\n      };\n    }\n  }\n\n  sigma.utils.map = SigmaMap;\n\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number}  x1  The X coordinate of the start point.\n   * @param  {number}  y1  The Y coordinate of the start point.\n   * @param  {number}  x2  The X coordinate of the end point.\n   * @param  {number}  y2  The Y coordinate of the end point.\n   * @param  {?number} cc  The curvature coefficients.\n   * @return {x,y}         The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2, cc) {\n    cc = this.extend(cc, { x: 2, y: 4 });\n    return {\n      x: (x1 + x2) / cc.x + (y2 - y1) / cc.y,\n      y: (y1 + y2) / cc.x + (x1 - x2) / cc.y\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * xi + t * t * x2,\n      y: (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * yi + t * t * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = (1 - t) * (1 - t) * (1 - t),\n        B1_t = 3 * t * (1 - t) * (1 - t),\n        B2_t = 3 * t * t * (1 - t),\n        B3_t = t * t * t;\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    return sigma.utils.distancePointToSegment(x, y, x1, y1, x2, y2) < epsilon;\n  };\n\n  /**\n    * Compute the distance of a point to a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @return {number}         Distance to the segment\n  */\n  sigma.utils.distancePointToSegment = function(x, y, x1, y1, x2, y2) {\n    // http://stackoverflow.com/a/6853926/1075195\n    var A = x - x1,\n        B = y - y1,\n        C = x2 - x1,\n        D = y2 - y1,\n        dot = A * C + B * D,\n        len_sq = C * C + D * D,\n        param = -1,\n        xx, yy;\n\n    if (len_sq !== 0) //in case of 0 length line\n        param = dot / len_sq;\n\n    if (param < 0) {\n      xx = x1;\n      yy = y1;\n    }\n    else if (param > 1) {\n      xx = x2;\n      yy = y2;\n    }\n    else {\n      xx = x1 + param * C;\n      yy = y1 + param * D;\n    }\n\n    var dx = x - xx;\n    var dy = y - yy;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio),\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n\n  /**\n   * Return true if the browser support webgl\n   *\n   * @return {boolean}\n   */\n  sigma.utils.isWebGLSupported = function() {\n    var canvas,\n        webgl = !!window.WebGLRenderingContext;\n    if (webgl) {\n      canvas = document.createElement('canvas');\n      try {\n        return !!(\n          canvas.getContext('webgl') ||\n          canvas.getContext('experimental-webgl')\n        );\n      } catch (e) {}\n    }\n    return false;\n  };\n\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n\n\n  /**\n   * ************\n   * CANVAS UTILS:\n   * ************\n   */\n  /**\n   * Calculate the width of the text either approximated via the font size or\n   * via the more expensive but accurate context.measureText.\n   *\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {boolean}     approximate   Approximate or not.\n   * @param  {integer}     fontSize      Font size of the text.\n   * @param  {string}      text          The text to use.\n   *\n   * @return {float}       Returns the width.\n   */\n   sigma.utils.canvas = {};\n   sigma.utils.canvas.getTextWidth =\n        function(context, approximate, fontSize, text) {\n\n    if (!text) return 0;\n\n    return approximate ? 0.6 * text.length * fontSize :\n      context.measureText(text).width;\n  };\n\n  /**\n   * Set the shadow values of the specified context according to the level\n   * to create visual depth.\n   *\n   * @param  {number}     level     The level (from 1 to 5).\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   */\n  sigma.utils.canvas.setLevel = function(level, context) {\n    if (level) {\n      context.shadowOffsetX = 0;\n      // inspired by Material Design shadows, level from 1 to 5:\n      switch(level) {\n        case 1:\n          context.shadowOffsetY = 1.5;\n          context.shadowBlur = 4;\n          context.shadowColor = 'rgba(0,0,0,0.36)';\n          break;\n        case 2:\n          context.shadowOffsetY = 3;\n          context.shadowBlur = 12;\n          context.shadowColor = 'rgba(0,0,0,0.39)';\n          break;\n        case 3:\n          context.shadowOffsetY = 6;\n          context.shadowBlur = 12;\n          context.shadowColor = 'rgba(0,0,0,0.42)';\n          break;\n        case 4:\n          context.shadowOffsetY = 10;\n          context.shadowBlur = 20;\n          context.shadowColor = 'rgba(0,0,0,0.47)';\n          break;\n        case 5:\n          context.shadowOffsetY = 15;\n          context.shadowBlur = 24;\n          context.shadowColor = 'rgba(0,0,0,0.52)';\n          break;\n      }\n    }\n  };\n\n  /**\n   * Reset the shadow values.\n   *\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   */\n  sigma.utils.canvas.resetLevel = function(context) {\n    context.shadowOffsetY = 0;\n    context.shadowBlur = 0;\n    context.shadowColor = '#000000';\n  };\n\n  // incrementally scaled, not automatically resized for now\n  // (ie. possible memory leak if there are many graph load / unload)\n  var imgCache = {};\n\n  /**\n   * Draw an image inside the specified node on the canvas.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {number}                   x        The node x coordinate.\n   * @param  {number}                   y        The node y coordinate.\n   * @param  {number}                   size     The node size.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {string}                   imgCrossOrigin Cross-origin URL or '*'.\n   * @param  {number}                  threshold Display if node size is larger\n   * @param  {function}                 clipFn    The clipping shape function.\n   */\n  sigma.utils.canvas.drawImage =\n    function(node, x, y, size, context, imgCrossOrigin, threshold, clipFn) {\n\n    if(!node.image || !node.image.url || size < threshold) return;\n\n    var url = node.image.url;\n    var ih = node.image.h || 1; // 1 is arbitrary, anyway only the ratio counts\n    var iw = node.image.w || 1;\n    var scale = node.image.scale || 1;\n    var clip = node.image.clip || 1;\n\n    // create new IMG or get from imgCache\n    var image = imgCache[url];\n    if(!image) {\n      image = document.createElement('IMG');\n      image.setAttribute('crossOrigin', imgCrossOrigin);\n      image.src = url;\n      image.onload = function() {\n        window.dispatchEvent(new Event('resize'));\n      };\n      imgCache[url] = image;\n    }\n\n    // calculate position and draw\n    var xratio = (iw < ih) ? (iw / ih) : 1;\n    var yratio = (ih < iw) ? (ih / iw) : 1;\n    var r = size * scale;\n\n    context.save(); // enter clipping mode\n      context.beginPath();\n    if (typeof clipFn === 'function') {\n      clipFn(node, x, y, size, context, clip);\n    }\n    else {\n      // Draw the clipping disc:\n      context.arc(x, y, size * clip, 0, Math. PI * 2, true);\n    }\n    context.closePath();\n    context.clip();\n\n    // Draw the actual image\n    context.drawImage(\n      image,\n      x + Math.sin(-3.142 / 4) * r * xratio,\n      y - Math.cos(-3.142 / 4) * r * yratio,\n      r * xratio * 2 * Math.sin(-3.142 / 4) * (-1),\n      r * yratio * 2 * Math.cos(-3.142 / 4)\n    );\n    context.restore(); // exit clipping mode\n  };\n\n  /**\n   * Draw an icon inside the specified node on the canvas.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {number}                   x        The node x coordinate.\n   * @param  {number}                   y        The node y coordinate.\n   * @param  {number}                   size     The node size.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {number}                  threshold Display if node size is larger\n   */\n  sigma.utils.canvas.drawIcon = function(node, x, y, size, context, threshold){\n    if(!node.icon || size < threshold) return;\n\n    var font = node.icon.font || 'Arial',\n        fgColor = node.icon.color || '#F00',\n        text = node.icon.content || '?',\n        px = node.icon.x || 0.5,\n        py = node.icon.y || 0.5,\n        height = size,\n        width = size;\n\n    var fontSizeRatio = 0.70;\n    if (typeof node.icon.scale === \"number\") {\n      fontSizeRatio = Math.abs(Math.max(0.01, node.icon.scale));\n    }\n\n    var fontSize = Math.round(fontSizeRatio * height);\n\n    context.save();\n    context.fillStyle = fgColor;\n\n    context.font = '' + fontSize + 'px ' + font;\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.fillText(text, x, y);\n    context.restore();\n  };\n\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  /**\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n   * requestAnimationFrame polyfill by Erik Möller.\n   * fixes from Paul Irish and Tino Zijdel\n   * MIT license\n   */\n  var x,\n      lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {\n    global.requestAnimationFrame =\n      global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame =\n      global[vendors[x] + 'CancelAnimationFrame'] ||\n      global[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!global.requestAnimationFrame)\n    global.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = global.setTimeout(\n            function() {\n              callback(currTime + timeToCall);\n            },\n            timeToCall\n          );\n\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n  if (!global.cancelAnimationFrame)\n    global.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n\n  /**\n   * Function.prototype.bind polyfill found on MDN.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\n   * Public domain\n   */\n  if (!Function.prototype.bind)\n    Function.prototype.bind = function(oThis) {\n      if (typeof this !== 'function')\n        // Closest thing possible to the ECMAScript 5 internal IsCallable\n        // function:\n        throw new TypeError(\n          'Function.prototype.bind - what is trying to be bound is not callable'\n        );\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP,\n          fBound;\n\n      fNOP = function() {};\n      fBound = function() {\n        return fToBind.apply(\n          this instanceof fNOP && oThis ?\n            this :\n            oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments))\n        );\n      };\n\n      fNOP.prototype = this.prototype;\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n})(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: false,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Label position relative to its node. Available values:\n    //          \"right\", \"left\", \"top\", \"bottom\", \"center\", \"inside\"\n    labelAlignment: 'right',\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} Maximum length of a node's label (in characters). Displays the label on several lines. 0 disables it\n    // (the whole label is displayed on one line)\n    maxNodeLabelLineLength: 0,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of nodes.\n    nodeBorderSize: 0,\n    // {number} The default node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n    // {boolean} Approximate labels width instead of using canvas.measureText\n    approximateLabelWidth: true,\n    // {boolean} Hide edges from nodes too far away\n    edgesClippingWithNodes: true,\n    // {number} if sigma.canvas.edges.autoCurve is called, set relative\n    // distance between curved parallel edges (i.e. edges with same\n    // extremities). Smaller value increases distances.\n    autoCurveRatio: 1,\n    // {boolean} if sigma.canvas.edges.autoCurve is called, sort edges by\n    // direction.\n    autoCurveSortByDirection: true,\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean} If true, the user will need to click on the visualization element\n    // in order to focus it\n    clickToFocus: false,\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {boolean} Defines whether the zoom focuses on the mouse location.\n    zoomOnLocation: true,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n    /**\n     * SPATIAL INDEXING SETTINGS:\n     * ****************\n     */\n    // {number} Max height of the node quad tree.\n    nodeQuadtreeMaxLevel: 4,\n    // {number} Max height of the edge quad tree.\n    edgeQuadtreeMaxLevel: 4,\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    this.dispatcher = dispatcher;\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    this.configurable = configurable;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: new sigma.utils.map(),\n      edgesIndex: new sigma.utils.map(),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: new sigma.utils.map(),\n      outNeighborsIndex: new sigma.utils.map(),\n      allNeighborsIndex: new sigma.utils.map()\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex.get(node.id))\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Try to fix the node coordinates and size\n    if (validNode.x !== undefined && typeof validNode.x !== 'number') {\n      validNode.x = parseFloat(validNode.x);\n    }\n    if (validNode.y !== undefined && typeof validNode.y !== 'number') {\n      validNode.y = parseFloat(validNode.y);\n    }\n    if (validNode.size !== undefined && typeof validNode.size !== 'number') {\n      validNode.size = parseFloat(validNode.size);\n    }\n\n    // Check node size\n    if (!validNode.size || validNode.size <= 0) {\n      validNode.size = 1;\n    }\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex.set(id, new sigma.utils.map());\n    this.outNeighborsIndex.set(id, new sigma.utils.map());\n    this.allNeighborsIndex.set(id, new sigma.utils.map());\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex.set(validNode.id, validNode);\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex.get(edge.source))\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex.get(edge.target))\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex.get(edge.id))\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Try to fix the edge size\n    if (validEdge.size !== undefined && typeof validEdge.size !== 'number') {\n      validEdge.size = parseFloat(validEdge.size);\n    }\n\n    // Check edge size\n    if (!validEdge.size || validEdge.size <= 0) {\n      validEdge.size = 1;\n    }\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex.set(validEdge.id, validEdge);\n\n    if (!this.inNeighborsIndex.get(validEdge.target).get(validEdge.source))\n      this.inNeighborsIndex.get(validEdge.target).set(validEdge.source,\n        new sigma.utils.map());\n    this.inNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,\n      validEdge);\n\n    if (!this.outNeighborsIndex.get(validEdge.source).get(validEdge.target))\n      this.outNeighborsIndex.get(validEdge.source).set(validEdge.target,\n        new sigma.utils.map());\n    this.outNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,\n      validEdge);\n\n    if (!this.allNeighborsIndex.get(validEdge.source).get(validEdge.target))\n      this.allNeighborsIndex.get(validEdge.source).set(validEdge.target,\n        new sigma.utils.map());\n    this.allNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,\n      validEdge);\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex.get(validEdge.target).get(validEdge.source))\n        this.allNeighborsIndex.get(validEdge.target).set(validEdge.source,\n          new sigma.utils.map());\n      this.allNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,\n        validEdge);\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex.get(id))\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    this.nodesIndex.delete(id);\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    this.inNeighborsIndex.delete(id);\n    this.outNeighborsIndex.delete(id);\n    this.allNeighborsIndex.delete(id);\n\n    var self = this;\n    this.nodesIndex.forEach(function(n, k) {\n      self.inNeighborsIndex.get(k).delete(id);\n      self.outNeighborsIndex.get(k).delete(id);\n      self.allNeighborsIndex.get(k).delete(id);\n    });\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex.get(id))\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex.get(id);\n    this.edgesIndex.delete(id);\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    this.inNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);\n    if (this.inNeighborsIndex.get(edge.target).get(edge.source).size == 0)\n      this.inNeighborsIndex.get(edge.target).delete(edge.source);\n\n    this.outNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);\n    if (this.outNeighborsIndex.get(edge.source).get(edge.target).size == 0)\n      this.outNeighborsIndex.get(edge.source).delete(edge.target);\n\n    this.allNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);\n    if (this.allNeighborsIndex.get(edge.source).get(edge.target).size == 0)\n      this.allNeighborsIndex.get(edge.source).delete(edge.target);\n\n    if (edge.target !== edge.source) {\n      this.allNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);\n      if (this.allNeighborsIndex.get(edge.target).get(edge.source).size == 0)\n        this.allNeighborsIndex.get(edge.target).delete(edge.source);\n    }\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    this.nodesIndex.clear();\n    this.edgesIndex.clear();\n    this.nodesIndex.clear();\n    this.inNeighborsIndex.clear();\n    this.outNeighborsIndex.clear();\n    this.allNeighborsIndex.clear();\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex.get(v);\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex.get(v[i]));\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsIndex,\n      'out': this.outNeighborsIndex\n    }[which || ''] || this.allNeighborsIndex;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which.get(v).size;\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which.get(v[i]).size);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex.get(v);\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex.get(v[i]));\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    this.graph = graph;\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ('ratio' in coordinates && !this.settings('zoomOnLocation'))\n          ? ['ratio', 'angle'] : ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal), Sébastien Heymann, Damien Marié\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          (r.x2 - r.x1) * (r.x2 - r.x1) +\n          (r.y2 - r.y1) * (r.y2 - r.y1)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (a.x * a.x + a.y * a.y)\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * @param  {boolean?} indexEdges Tell to index edges or nodes\n   *\n   * property {object} _tree       Property holding the quadtree object\n   * property {object} _geom       Exposition of the _geom namespace for testing\n   * property {object} _cache      Cache for the area method\n   */\n  var quad = function(indexEdges) {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n    this._indexEdges = indexEdges || false;\n  };\n\n  /**\n   * Index a graph by inserting its elements into the quadtree.\n   *\n   * @param  {array}  graph      The graph to index\n   * @param  {object} params     An object of parameters with at least the quad\n   *                             bounds.\n   * @return {object}            The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(graph, params) {\n    if (!this._enabled) {\n      return this._tree;\n    }\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        cc = params.curvatureCoefficients,\n        source,\n        target,\n        i,\n        l,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    if (!this._indexEdges) {\n      var nodes = graph.nodes();\n      // Inserting graph nodes into the tree\n      for (i = 0, l = nodes.length; i < l; i++) {\n\n        // Inserting node\n        _quadInsert(\n          nodes[i],\n          _geom.pointToSquare({\n            x: nodes[i][prefix + 'x'],\n            y: nodes[i][prefix + 'y'],\n            size: nodes[i][prefix + 'size']\n          }),\n          this._tree\n        );\n      }\n    } else {\n      var edges = graph.edges();\n      // Inserting graph edges into the tree\n      for (i = 0, l = edges.length; i < l; i++) {\n        source = graph.nodes(edges[i].source);\n        target = graph.nodes(edges[i].target);\n        e = {\n          x1: source[prefix + 'x'],\n          y1: source[prefix + 'y'],\n          x2: target[prefix + 'x'],\n          y2: target[prefix + 'y'],\n          size: edges[i][prefix + 'size'] || 0\n        };\n\n        // Inserting edge\n        if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n          if (source.id === target.id) {\n            n = {\n              x: source[prefix + 'x'],\n              y: source[prefix + 'y'],\n              size: source[prefix + 'size'] || 0\n            };\n            _quadInsert(\n              edges[i],\n              _geom.selfLoopToSquare(n),\n              this._tree);\n          }\n          else {\n            cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2, edges[i].cc || cc);\n            _quadInsert(\n              edges[i],\n              _geom.quadraticCurveToSquare(e, cp),\n              this._tree);\n          }\n        }\n        else {\n          _quadInsert(\n            edges[i],\n            _geom.lineToSquare(e),\n            this._tree);\n        }\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var elements = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var elementsArr = [];\n    for (var i in elements)\n      elementsArr.push(elements[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = elementsArr;\n\n    return elementsArr;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n    this.sigma.classes.edgequad = quad.bind(this, true);\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    this.quad = quad;\n\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    this.eltFocused = false;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    _target.addEventListener('mouseenter', _enterHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    function _enterHandler(e) {\n      if (!_settings('clickToFocus')) {\n        target.focus();\n      }\n    }\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      _self.eltFocused = false;\n      target.blur();\n\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      _self.eltFocused = true;\n      target.focus();\n\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && (!_settings('clickToFocus') || _self.eltFocused)) {\n        ratio = sigma.utils.getDelta(e) > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n  /**\n   * Static method to render edges or nodes with the given renderers\n   *\n   * @param  {object}       params     The parameters passed in an object\n   * {\n   *   renderers: {object}              Renderers indexed by types\n   *   type:      {string}              \"edges\" or \"nodes\"\n   *   ctx:       {Context2D}           Canvas Context to draw on\n   *   settings:  {object}              Settings object to use\n   *   elements:  {array}               Elements to render\n   *   graph?:    {sigma.classes.graph} Graph object\n   *                                    (only necessary for edge rendering)\n   *   start?:    {integer}             Starting index of the elements to render\n   *   end?:      {integer}             Last index of the elements to render\n   * }\n   */\n  sigma.renderers.canvas.applyRenderers = function(params) {\n    var i,\n        renderer,\n        specializedRenderer,\n        def,\n        render,\n        els = params.elements,\n        ctx_infos = {font: params.ctx.font},\n        elementType = (params.elements || params.type == 'edges' ?\n              'defaultEdgeType' : 'defaultNodeType');\n\n    params.start = params.start || 0;\n    params.end = params.end || params.elements.length;\n    params.end = Math.min(params.elements.length, params.end);\n\n    params.ctx.save();\n\n    for (i = params.start; i < params.end; i++) {\n      if (!els[i].hidden) {\n        specializedRenderer = params.renderers[\n          els[i].type || params.settings(elementType)\n        ];\n        def = (specializedRenderer || params.renderers.def);\n        if (params.type == 'edges') {\n          def(\n            els[i],\n            params.graph.nodes(els[i].source),\n            params.graph.nodes(els[i].target),\n            params.ctx,\n            params.settings,\n            {ctx: ctx_infos}\n          );\n        }else {\n          def(\n            els[i],\n            params.ctx,\n            params.settings,\n            {ctx: ctx_infos}\n          );\n        }\n      }\n    }\n\n    params.ctx.restore();\n  };\n\n\n  /**\n   * Render a batch of edges\n   *\n   * @param    {integer}      start    Starting index of the elements to render\n   * @param    {integer}      end      Last index of the elements to render\n   * @param    {object}       settings Settings to use\n   */\n  sigma.renderers.canvas.prototype.renderEdges =\n          function(start, end, settings) {\n    var renderParams = {\n      renderers: sigma.canvas.edges,\n      type: 'edges',\n      elements: this.edgesOnScreen,\n      ctx: this.contexts.edges,\n      start: start,\n      end: end,\n      graph: this.graph,\n      settings: settings\n    };\n    sigma.renderers.canvas.applyRenderers(renderParams);\n    if (settings('drawEdgeLabels')) {\n      renderParams.renderers = sigma.canvas.edges.labels;\n      renderParams.ctx = this.contexts.labels;\n      sigma.renderers.canvas.applyRenderers(renderParams);\n    }\n  };\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    this.dispatchEvent('beforeRender');\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      this.edgesOnScreen = [];\n      if (embedSettings('edgesClippingWithNodes')) {\n        // Identify which edges to draw by keeping every edges that have at\n        // least one extremity displayed according to the quadtree and the\n        // \"hidden\" attribute. We also do not keep hidden edges.\n        for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          if (\n            (index[o.source] || index[o.target]) &&\n            (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n          )\n            this.edgesOnScreen.push(o);\n        }\n      } else {\n        this.edgesOnScreen = this.camera.edgequadtree.area(\n          this.camera.getRectangle(this.width, this.height)\n        );\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (embedSettings('batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          this.renderEdges(start, end, embedSettings);\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        this.renderEdges(0, this.edgesOnScreen.length, embedSettings);\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      sigma.renderers.canvas.applyRenderers({\n        renderers: sigma.canvas.nodes,\n        type: 'nodes',\n        ctx: this.contexts.nodes,\n        elements: this.nodesOnScreen,\n        settings: embedSettings\n      });\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      sigma.renderers.canvas.applyRenderers({\n        renderers: sigma.canvas.labels,\n        type: 'nodes',\n        ctx: this.contexts.labels,\n        elements: this.nodesOnScreen,\n        settings: embedSettings\n      });\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      edgelabels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    this.dispatchEvent('beforeRender');\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n    this.hideDOMElements(this.domElements.edgelabels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          if (drawLabels) {\n            e = (subrenderers[a[i].type] || subrenderers.def).create(\n              a[i],\n              embedSettings\n            );\n\n            this.domElements.labels[a[i].id] = e;\n            this.domElements.groups.labels.appendChild(e);\n          }\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        if (drawLabels) {\n          (subrenderers[a[i].type] || subrenderers.def).update(\n            a[i],\n            this.domElements.labels[a[i].id],\n            embedSettings\n          );\n        }\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n    subrenderers = sigma.svg.edges.labels;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] ||\n            renderers[defaultEdgeType] ||\n            renderers.def\n          ).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n\n          // Label\n          if (drawEdgeLabels) {\n\n            e = (subrenderers[a[i].type] ||\n              subrenderers[defaultEdgeType]  ||\n              subrenderers.def\n            ).create(\n              a[i],\n              embedSettings\n            );\n            this.domElements.edgelabels[a[i].id] = e;\n            this.domElements.groups.edgelabels.appendChild(e);\n          }\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] ||\n          renderers[defaultEdgeType] ||\n          renderers.def\n        ).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n\n        // Label\n        if (drawEdgeLabels) {\n          (subrenderers[a[i].type] ||\n            subrenderers[defaultEdgeType] ||\n            subrenderers.def\n          ).update(\n            a[i],\n            source,\n            target,\n            this.domElements.edgelabels[a[i].id],\n            embedSettings\n          );\n        }\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'edgelabels', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function updateHovers(e) {\n      var node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      if (e.data.enter.nodes.length > 0) { // over\n        node = e.data.enter.nodes[0];\n        var hover = (renderers[node.type] || renderers.def).create(\n          node,\n          self.domElements.nodes[node.id],\n          self.measurementCanvas,\n          embedSettings\n        );\n\n        self.domElements.hovers[node.id] = hover;\n\n        // Inserting the hover in the dom\n        self.domElements.groups.hovers.appendChild(hover);\n        hoveredNode = node;\n      } else if (e.data.leave.nodes.length > 0) { // out\n        node = e.data.leave.nodes[0];\n\n        // Deleting element\n        self.domElements.groups.hovers.removeChild(\n          self.domElements.hovers[node.id]\n        );\n        hoveredNode = null;\n        delete self.domElements.hovers[node.id];\n\n        // Reinstate\n        self.domElements.groups.nodes.appendChild(\n          self.domElements.nodes[node.id]\n        );\n      }\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('hovers', updateHovers);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = this.width + 'px';\n      this.domElements.graph.style.height = this.height + 'px';\n    }\n\n    return this;\n  };\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n  sigma.utils.pkg('sigma.svg.edgelabels');\n}).call(this);\n\n;(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Copy the good renderer:\n  sigma.renderers.def = sigma.utils.isWebGLSupported() ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will display the label of the node\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   * @param  {object?}                  infos    The batch infos.\n   */\n  sigma.canvas.labels.def = function(node, context, settings, infos) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'] || 1,\n        fontStyle = settings('fontStyle'),\n        borderSize = settings('nodeBorderSize'),\n        labelWidth,\n        labelOffsetX,\n        labelOffsetY,\n        alignment = settings('labelAlignment'),\n        maxLineLength = settings('maxNodeLabelLineLength') || 0;\n\n    if (size <= settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    var new_font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' +\n      (node.active ?\n        settings('activeFont') || settings('font') :\n        settings('font'));\n\n    if (infos && infos.ctx.font != new_font) { //use font value caching\n      context.font = new_font;\n      infos.ctx.font = new_font;\n    } else {\n      context.font = new_font;\n    }\n\n    context.fillStyle =\n        (settings('labelColor') === 'node') ?\n        node.color || settings('defaultNodeColor') :\n        settings('defaultLabelColor');\n\n    labelOffsetX = 0;\n    labelOffsetY = fontSize / 3;\n    context.textAlign = 'center';\n\n    switch (alignment) {\n      case 'bottom':\n        labelOffsetY = + size + 4 * fontSize / 3;\n        break;\n      case 'center':\n        break;\n      case 'left':\n        context.textAlign = 'right';\n        labelOffsetX = - size - borderSize - 3;\n        break;\n      case 'top':\n        labelOffsetY = - size - 2 * fontSize / 3;\n        break;\n      case 'inside':\n        labelWidth = sigma.utils.canvas.getTextWidth(context, settings('approximateLabelWidth'), fontSize, node.label);\n        if (labelWidth <= (size + fontSize / 3) * 2) {\n          break;\n        }\n      /* falls through*/\n      case 'right':\n      /* falls through*/\n      default:\n        labelOffsetX = size + borderSize + 3;\n        context.textAlign = 'left';\n        break;\n    }\n\n    var lines = getLines(node.label, maxLineLength),\n        baseX = node[prefix + 'x'] + labelOffsetX,\n        baseY = Math.round(node[prefix + 'y'] + labelOffsetY);\n\n    for (var i = 0; i < lines.length; ++i) {\n      context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));\n    }\n  };\n\n  /**\n   * Split a text into several lines. Each line won't be longer than the specified maximum length.\n   * @param {string}  text            Text to split\n   * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as \"infinity\".\n   * @returns {Array<string>}         List of lines\n   */\n  function getLines(text, maxLineLength) {\n    if (maxLineLength <= 1) {\n      return [text];\n    }\n\n    var words = text.split(' '),\n        lines = [],\n        lineLength = 0,\n        lineIndex = -1,\n        lineList = [],\n        lineFull = true;\n\n    for (var i = 0; i < words.length; ++i) {\n      if (lineFull) {\n        if (words[i].length > maxLineLength) {\n          var parts = splitWord(words[i], maxLineLength);\n          for (var j = 0; j < parts.length; ++j) {\n            lines.push([parts[j]]);\n            ++lineIndex;\n          }\n          lineLength = parts[parts.length - 1].length;\n        } else {\n          lines.push([words[i]\n          ]);\n          ++lineIndex;\n          lineLength = words[i].length + 1;\n        }\n        lineFull = false;\n      } else if (lineLength + words[i].length <= maxLineLength) {\n        lines[lineIndex].push(words[i]);\n        lineLength += words[i].length + 1;\n      } else {\n        lineFull = true;\n        --i;\n      }\n    }\n\n    for (i = 0; i < lines.length; ++i) {\n      lineList.push(lines[i].join(' '))\n    }\n\n    return lineList;\n  }\n\n  /**\n   * Split a word into several lines (with a '-' at the end of each line but the last).\n   * @param {string} word       Word to split\n   * @param {number} maxLength  Maximum length of a line\n   * @returns {Array<string>}   List of lines\n   */\n  function splitWord(word, maxLength) {\n    var parts = [];\n\n    for (var i = 0; i < word.length; i += maxLength - 1) {\n      parts.push(word.substr(i, maxLength - 1) + '-');\n    }\n\n    var lastPartLen = parts[parts.length - 1].length;\n    parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';\n\n    return parts;\n  }\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        labelX,\n        labelY,\n        lines,\n        baseX,\n        baseY,\n        borderSize = settings('nodeBorderSize'),\n        alignment = settings('labelAlignment'),\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        maxLineLength = settings('maxNodeLabelLineLength') || 0,\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    lines = getLines(node.label, maxLineLength);\n    drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength);\n\n    // Node border:\n    if (borderSize > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + borderSize,\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n      var labelWidth = sigma.utils.canvas.getTextWidth(context,\n            settings('approximateLabelWidth'), fontSize, node.label),\n          labelOffsetX = - labelWidth / 2,\n          labelOffsetY = fontSize / 3;\n\n      switch (alignment) {\n        case 'bottom':\n          labelOffsetY = + size + 4 * fontSize / 3;\n          break;\n        case 'center':\n          break;\n        case 'left':\n          labelOffsetX = - size - borderSize - 3 - labelWidth;\n          break;\n        case 'top':\n          labelOffsetY = - size - 2 * fontSize / 3;\n          break;\n        case 'inside':\n          if (labelWidth <= (size + fontSize / 3) * 2) {\n            break;\n          }\n        /* falls through*/\n        case 'right':\n        /* falls through*/\n        default:\n          labelOffsetX = size + borderSize + 3;\n          break;\n      }\n\n      baseX = node[prefix + 'x'] + labelOffsetX;\n      baseY = Math.round(node[prefix + 'y'] + labelOffsetY);\n\n      for (var i = 0; i < lines.length; ++i) {\n        context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));\n      }\n    }\n\n    function drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength) {\n      var labelWidth =\n        (maxLineLength > 1 && lines.length > 1) ?\n        0.6 * maxLineLength * fontSize :\n        sigma.utils.canvas.getTextWidth(\n          context,\n          settings('approximateLabelWidth'),\n          fontSize,\n          lines[0]\n        );\n\n      var x = Math.round(node[prefix + 'x']),\n          y = Math.round(node[prefix + 'y']),\n          h = ((fontSize + 1) * lines.length) + 4,\n          e = Math.round(size + fontSize / 4),\n          w = Math.round(labelWidth + size + 1.5 + fontSize / 3);\n\n      if (node.label && typeof node.label === 'string') {\n        // draw a rectangle for the label\n        switch (alignment) {\n          case 'center':\n            break;\n          case 'left':\n            x = Math.round(node[prefix + 'x'] + fontSize / 2 + 2);\n            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n\n            context.moveTo(x, y + e);\n            context.arcTo(x, y, x - e, y, e);\n            context.lineTo(x - w - borderSize - e, y);\n            context.lineTo(x - w - borderSize - e, y + h);\n            context.lineTo(x - e, y + h);\n            context.arcTo(x, y + h, x, y + h - e, e);\n            context.lineTo(x, y + e);\n            break;\n          case 'top':\n            context.rect(x - w / 2, y - e - h, w, h);\n            break;\n          case 'bottom':\n            context.rect(x - w / 2, y + e, w, h);\n            break;\n          case 'inside':\n            if (labelWidth <= e * 2) {\n              // don't draw anything\n              break;\n            }\n            // use default setting, falling through\n          /* falls through*/\n          case 'right':\n          /* falls through*/\n          default:\n            x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n\n            context.moveTo(x, y + e);\n            context.arcTo(x, y, x + e, y, e);\n            context.lineTo(x + w + borderSize + e, y);\n            context.lineTo(x + w + borderSize + e, y + h);\n            context.lineTo(x + e, y + h);\n            context.arcTo(x, y + h, x, y + h - e, e);\n            context.lineTo(x, y + e);\n            break;\n        }\n      }\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    /**\n     * Split a text into several lines. Each line won't be longer than the specified maximum length.\n     * @param {string}  text            Text to split\n     * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as \"infinity\".\n     * @returns {Array<string>}         List of lines\n     */\n    function getLines(text, maxLineLength) {\n      if (maxLineLength <= 1) {\n        return [text];\n      }\n\n      var words = text.split(' '),\n        lines = [],\n        lineLength = 0,\n        lineIndex = -1,\n        lineList = [],\n        lineFull = true;\n\n      for (var i = 0; i < words.length; ++i) {\n        if (lineFull) {\n          if (words[i].length > maxLineLength) {\n            var parts = splitWord(words[i], maxLineLength);\n            for (var j = 0; j < parts.length; ++j) {\n              lines.push([parts[j]]);\n              ++lineIndex;\n            }\n            lineLength = parts[parts.length - 1].length;\n          } else {\n            lines.push([words[i]\n            ]);\n            ++lineIndex;\n            lineLength = words[i].length + 1;\n          }\n          lineFull = false;\n        } else if (lineLength + words[i].length <= maxLineLength) {\n          lines[lineIndex].push(words[i]);\n          lineLength += words[i].length + 1;\n        } else {\n          lineFull = true;\n          --i;\n        }\n      }\n\n      for (i = 0; i < lines.length; ++i) {\n        lineList.push(lines[i].join(' '))\n      }\n\n      return lineList;\n    }\n\n    /**\n     * Split a word into several lines (with a '-' at the end of each line but the last).\n     * @param {string} word       Word to split\n     * @param {number} maxLength  Maximum length of a line\n     * @returns {Array<string>}   List of lines\n     */\n    function splitWord(word, maxLength) {\n      var parts = [];\n\n      for (var i = 0; i < word.length; i += maxLength - 1) {\n        parts.push(word.substr(i, maxLength - 1) + '-');\n      }\n\n      var lastPartLen = parts[parts.length - 1].length;\n      parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';\n\n      return parts;\n    }\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves with arrow heading.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n\n    if (source.id === target.id) {\n      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n\n    if (source.id === target.id) {\n      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));\n      aSize = Math.max(size * 2.5, settings('minArrowSize'));\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the edge as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               path       The path DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '',\n          sSize = source[prefix + 'size'],\n          sX = source[prefix + 'x'],\n          sY = source[prefix + 'y'],\n          tX = target[prefix + 'x'],\n          tY = target[prefix + 'y'],\n          cp,\n          p;\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      if (source.id === target.id) {\n        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);\n        // Path\n        p = 'M' + sX + ',' + sY + ' ' +\n            'C' + cp.x1 + ',' + cp.y1 + ' ' +\n            cp.x2 + ',' + cp.y2 + ' ' +\n            tX + ',' + tY;\n      }\n      else {\n        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n        // Path\n        p = 'M' + sX + ',' + sY + ' ' +\n            'Q' + cp.x + ',' + cp.y + ' ' +\n            tX + ',' + tY;\n      }\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * TODO add arrow\n   */\n  sigma.svg.edges.curvedArrow = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               path       The path DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '',\n          sSize = source[prefix + 'size'],\n          sX = source[prefix + 'x'],\n          sY = source[prefix + 'y'],\n          tX = target[prefix + 'x'],\n          tY = target[prefix + 'y'],\n          cp,\n          p;\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      if (source.id === target.id) {\n        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);\n        // Path\n        p = 'M' + sX + ',' + sY + ' ' +\n            'C' + cp.x1 + ',' + cp.y1 + ' ' +\n            cp.x2 + ',' + cp.y2 + ' ' +\n            tX + ',' + tY;\n      }\n      else {\n        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);\n        // Path\n        p = 'M' + sX + ',' + sY + ' ' +\n            'Q' + cp.x + ',' + cp.y + ' ' +\n            tX + ',' + tY;\n      }\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    if (np) {\n      /**\n       * First, we compute the scaling ratio, without considering the sizes\n       * of the nodes : Each node will have its center in the canvas, but might\n       * be partially out of it.\n       */\n      scale = settings('scalingMode') === 'outside' ?\n        Math.max(\n          w / Math.max(maxX - minX, 1),\n          h / Math.max(maxY - minY, 1)\n        ) :\n        Math.min(\n          w / Math.max(maxX - minX, 1),\n          h / Math.max(maxY - minY, 1)\n        );\n\n      /**\n       * Then, we correct that scaling ratio considering a margin, which is\n       * basically the size of the biggest node.\n       * This has to be done as a correction since to compare the size of the\n       * biggest node to the X and Y values, we have to first get an\n       * approximation of the scaling ratio.\n       **/\n      margin =\n        (\n          settings('rescaleIgnoreSize') ?\n            0 :\n            (settings('maxNodeSize') || sizeMax) / scale\n        ) +\n        (settings('sideMargin') || 0);\n      maxX += margin;\n      minX -= margin;\n      maxY += margin;\n      minY -= margin;\n\n      // Fix the scaling with the new extrema:\n      scale = settings('scalingMode') === 'outside' ?\n        Math.max(\n          w / Math.max(maxX - minX, 1),\n          h / Math.max(maxY - minY, 1)\n        ) :\n        Math.min(\n          w / Math.max(maxX - minX, 1),\n          h / Math.max(maxY - minY, 1)\n        );\n    }\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n\n      if (np) {\n        n[i][writePrefix + 'x'] =\n          (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * scale;\n        n[i][writePrefix + 'y'] =\n          (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * scale;\n      }\n      else {\n        n[i][writePrefix + 'x'] = n[i][readPrefix + 'x'];\n        n[i][writePrefix + 'y'] = n[i][readPrefix + 'y'];\n      }\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              (modifiedX - x) * (modifiedX - x) +\n              (modifiedY - y) * (modifiedY - y)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  edge.cc);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            event = {\n              current: { nodes: [], edges: [], },\n              enter: { nodes: [], edges: [], },\n              leave: { nodes: [], edges: [], },\n              captor: e.data\n            },\n            leave = event.leave;\n\n        for (k in overNodes)\n          leave.nodes.push(overNodes[k]);\n\n        for (k in overEdges)\n          leave.edges.push(overEdges[k]);\n\n        overNodes = {};\n        overEdges = {};\n\n        if (leave.nodes.length || leave.edges.length) {\n          self.dispatchEvent('hovers', event);\n        }\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {};\n\n        // Check newly overred nodes:\n        for (i = 0; i < nodes.length; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Check newly overred edges:\n        for (i = 0; i < edges.length; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        if (newOutEdges.length || newOverEdges.length ||\n             newOutNodes.length || newOverNodes.length) {\n          self.dispatchEvent('hovers', {\n            current: {\n              nodes: nodes,\n              edges: edges,\n            },\n            enter: {\n              nodes: newOverNodes,\n              edges: newOverEdges,\n            },\n            leave: {\n              nodes: newOutNodes,\n              edges: newOutEdges,\n            },\n            captor: e.data\n          });\n        }\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph,\n        hovered = {nodes: [], edges: []};\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', sigma.utils.mouseCoords(e));\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', sigma.utils.mouseCoords(e));\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el_svg = new Element(target),\n        event = {\n          leave: {nodes: [], edges: []},\n          enter: {nodes: [], edges: []},\n          captor: sigma.utils.mouseCoords(e),\n        },\n        el;\n\n      if (el_svg.isNode()) {\n        el = graph.nodes(el_svg.attr('data-node-id'));\n        event.enter.nodes = [el];\n        hovered.nodes.push(el);\n      } else if (el_svg.isEdge()) {\n        el = graph.edges(el_svg.attr('data-edge-id'));\n        event.enter.edges = [el];\n        hovered.edges.push(el);\n      }\n\n      event.current = hovered;\n      self.dispatchEvent('hovers', event);\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el_svg = new Element(target),\n        event = {\n          leave: {nodes: [], edges: []},\n          enter: {nodes: [], edges: []},\n          captor: sigma.utils.mouseCoords(e),\n        },\n        el;\n\n      if (el_svg.isNode()) {\n        el = graph.nodes(el_svg.attr('data-node-id'));\n        event.leave.nodes = [el];\n        hovered.nodes.push(el);\n      } else if (el_svg.isEdge()) {\n        el = graph.edges(el_svg.attr('data-edge-id'));\n        event.leave.edges = [el];\n        hovered.edges.push(el);\n      } else {\n        return;\n      }\n\n      event.current = hovered;\n      self.dispatchEvent('hovers', event);\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"hovers\" events from a renderer and renders\n   * the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        current = {nodes: [], edges: []};\n\n    this.bind('hovers', function(event) {\n      current = event.data.current;\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n      var c = self.contexts.hover.canvas,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          }),\n          end = embedSettings('singleHover') ? 1 : undefined,\n          renderParams = {\n            elements: current.nodes,\n            renderers: sigma.canvas.hovers,\n            type: 'nodes',\n            ctx: self.contexts.hover,\n            end: end,\n            graph: self.graph,\n            settings: embedSettings,\n          };\n\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render\n      if (current.nodes.length > 0 && embedSettings('enableHovering')) {\n        sigma.renderers.canvas.applyRenderers(renderParams);\n      }\n\n      // Edge render\n      if (current.edges.length > 0 && embedSettings('enableEdgeHovering')) {\n        renderParams.renderers = sigma.canvas.edgehovers;\n        renderParams.elements = current.edges;\n        renderParams.type = 'edges';\n        sigma.renderers.canvas.applyRenderers(renderParams);\n\n        if (embedSettings('edgeHoverExtremities')) {\n          renderParams.renderers = sigma.canvas.extremities;\n          sigma.renderers.canvas.applyRenderers(renderParams);\n        } else { //draw nodes over edges\n          renderParams.ctx = self.contexts.nodes;\n          renderParams.type = 'nodes';\n          renderParams.renderers = sigma.canvas.nodes;\n          renderParams.elements = current.nodes;\n          sigma.renderers.canvas.applyRenderers(renderParams);\n        }\n      }\n    }\n  };\n}).call(this);\n","(function(a){\"use strict\";function b(a){var b={id:a.id,label:a.label};return a.viz&&(b.viz=a.viz),a.attributes&&(b.attributes=a.attributes),b}function c(a){var b={id:a.id,type:a.type||\"undirected\",label:a.label||\"\",source:a.source,target:a.target,weight:+a.weight||1};return a.viz&&(b.viz=a.viz),a.attributes&&(b.attributes=a.attributes),b}function d(a){function d(){var a={};return l.els.meta?(a.lastmodifieddate=l.els.meta.getAttribute(\"lastmodifieddate\"),h.nodeListEach(l.els.meta.childNodes,function(b){a[b.tagName.toLowerCase()]=b.textContent}),a):a}function e(a){var b=[];return l.els.model[a]&&h.nodeListEach(l.els.model[a],function(a){var c={id:a.getAttribute(\"id\")||a.getAttribute(\"for\"),type:a.getAttribute(\"type\")||\"string\",title:a.getAttribute(\"title\")||\"\"},d=h.nodeListToArray(a.childNodes);d.length>0&&(c.defaultValue=d[0].textContent),b.push(c)}),b.length>0&&b}function f(a,b){var c={},d=b.getElementsByTagName(\"attvalue\"),e=h.nodeListToHash(d,function(a){var b=h.namedNodeMapToObject(a.attributes),c=b.id||b[\"for\"];return{key:c,value:b.value}});return a.map(function(a){c[a.id]=!(a.id in e)&&\"defaultValue\"in a?h.enforceType(a.type,a.defaultValue):h.enforceType(a.type,e[a.id])}),c}function g(a){var c=[];return h.nodeListEach(l.els.nodes,function(d){var e={id:d.getAttribute(\"id\"),label:d.getAttribute(\"label\")||\"\"};a&&(e.attributes=f(a,d)),l.hasViz&&(e.viz=i(d)),c.push(b(e))}),c}function i(a){var b={},c=h.getFirstElementByTagNS(a,\"viz\",\"color\");if(c){var d=[\"r\",\"g\",\"b\",\"a\"].map(function(a){return c.getAttribute(a)});b.color=h.getRGB(d)}var e=h.getFirstElementByTagNS(a,\"viz\",\"position\");e&&(b.position={},[\"x\",\"y\",\"z\"].map(function(a){b.position[a]=+e.getAttribute(a)}));var f=h.getFirstElementByTagNS(a,\"viz\",\"size\");f&&(b.size=+f.getAttribute(\"value\"));var g=h.getFirstElementByTagNS(a,\"viz\",\"shape\");return g&&(b.shape=g.getAttribute(\"value\")),b}function j(a,b){var d=[];return h.nodeListEach(l.els.edges,function(e){var g=h.namedNodeMapToObject(e.attributes);\"type\"in g||(g.type=b),a&&(g.attributes=f(a,e)),l.hasViz&&(g.viz=k(e)),d.push(c(g))}),d}function k(a){var b={},c=h.getFirstElementByTagNS(a,\"viz\",\"color\");if(c){var d=[\"r\",\"g\",\"b\",\"a\"].map(function(a){return c.getAttribute(a)});b.color=h.getRGB(d)}var e=h.getFirstElementByTagNS(a,\"viz\",\"shape\");e&&(b.shape=e.getAttribute(\"value\"));var f=h.getFirstElementByTagNS(a,\"viz\",\"thickness\");return f&&(b.thickness=+f.getAttribute(\"value\")),b}var l={};l.els={root:a.getElementsByTagName(\"gexf\")[0],graph:a.getElementsByTagName(\"graph\")[0],meta:a.getElementsByTagName(\"meta\")[0],nodes:a.getElementsByTagName(\"node\"),edges:a.getElementsByTagName(\"edge\"),model:h.getModelTags(a)},l.hasViz=!!h.getAttributeNS(l.els.root,\"xmlns\",\"viz\"),l.version=l.els.root.getAttribute(\"version\")||\"1.0\",l.mode=l.els.graph.getAttribute(\"mode\")||\"static\";var m=l.els.graph.getAttribute(\"defaultedgetype\");l.defaultEdgetype=m||\"undirected\";var n=e(\"node\"),o=e(\"edge\"),p={version:l.version,mode:l.mode,defaultEdgeType:l.defaultEdgetype,meta:d(),model:{},nodes:g(n),edges:j(o,l.defaultEdgetype)};return n&&(p.model.node=n),o&&(p.model.edge=o),p}function e(a,b){var c=function(){if(window.XMLHttpRequest)return new XMLHttpRequest;var a,b;if(window.ActiveXObject){a=[\"Msxml2.XMLHTTP.6.0\",\"Msxml2.XMLHTTP.3.0\",\"Msxml2.XMLHTTP\",\"Microsoft.XMLHTTP\"];for(b in a)try{return new ActiveXObject(a[b])}catch(c){}}return null}();if(!c)throw\"XMLHttpRequest not supported, cannot load the file.\";var d,e=\"function\"==typeof b;return c.overrideMimeType?(c.overrideMimeType(\"text/xml\"),d=function(a){return a.responseXML}):d=function(a){var b=new DOMParser;return b.parseFromString(a.responseText,\"application/xml\")},c.open(\"GET\",a,e),e&&(c.onreadystatechange=function(){4===c.readyState&&b(d(c))}),c.send(),e?c:d(c)}function f(a){return d(a)}function g(a,b){return\"function\"==typeof b?e(a,function(a){b(d(a))}):d(e(a))}var h={getModelTags:function(a){var b,c=a.getElementsByTagName(\"attributes\"),d={},e=c.length;for(b=0;b<e;b++)d[c[b].getAttribute(\"class\")]=c[b].childNodes;return d},nodeListToArray:function(a){for(var b=[],c=0,d=a.length;c<d;++c)\"#text\"!==a[c].nodeName&&b.push(a[c]);return b},nodeListEach:function(a,b){for(var c=0,d=a.length;c<d;++c)\"#text\"!==a[c].nodeName&&b(a[c])},nodeListToHash:function(a,b){for(var c={},d=0;d<a.length;d++)if(\"#text\"!==a[d].nodeName){var e=b(a[d]);c[e.key]=e.value}return c},namedNodeMapToObject:function(a){for(var b={},c=0;c<a.length;c++)b[a[c].name]=a[c].value;return b},getFirstElementByTagNS:function(a,b,c){var d=a.getElementsByTagName(b+\":\"+c)[0];return d||(d=a.getElementsByTagNameNS(b,c)[0]),d||(d=a.getElementsByTagName(c)[0]),d},getAttributeNS:function(b,c,d){var e=b.getAttribute(c+\":\"+d);return e===a&&(e=b.getAttributeNS(c,d)),e===a&&(e=b.getAttribute(d)),e},enforceType:function(a,b){switch(a){case\"boolean\":b=\"true\"===b;break;case\"integer\":case\"long\":case\"float\":case\"double\":b=+b;break;case\"liststring\":b=b?b.split(\"|\"):[]}return b},getRGB:function(a){return a[3]?\"rgba(\"+a.join(\",\")+\")\":\"rgb(\"+a.slice(0,-1).join(\",\")+\")\"}};if(\"undefined\"!=typeof this.gexf)throw'gexf: error - a variable called \"gexf\" already exists in the global scope';this.gexf={parse:f,fetch:g,version:\"0.1.1\"},\"undefined\"!=typeof exports&&this.exports!==exports&&(module.exports=this.gexf)}).call(this),function(a){\"use strict\";function b(){return\"e\"+c++}if(\"undefined\"==typeof sigma)throw\"sigma is not declared\";sigma.utils.pkg(\"sigma.parsers\");var c=0;sigma.parsers.gexf=function(a,c,d){function e(a){for(h=a.nodes,f=0,g=h.length;f<g;f++)i=h[f],i.id=i.id,i.viz&&\"object\"==typeof i.viz&&(i.viz.position&&\"object\"==typeof i.viz.position&&(i.x=i.viz.position.x,i.y=-i.viz.position.y),i.size=i.viz.size,i.color=i.viz.color),i.attributes&&(i.attributes.latitude&&(i.lat=i.attributes.latitude),i.attributes.longitude&&(i.lng=i.attributes.longitude));for(h=a.edges,f=0,g=h.length;f<g;f++)i=h[f],i.id=\"string\"==typeof i.id?i.id:b(),i.source=\"\"+i.source,i.target=\"\"+i.target,i.viz&&\"object\"==typeof i.viz&&(i.color=i.viz.color,i.size=i.viz.thickness),i.size=i.weight,i.direction=i.type,delete i.type;if(c instanceof sigma){for(c.graph.clear(),h=a.nodes,f=0,g=h.length;f<g;f++)c.graph.addNode(h[f]);for(h=a.edges,f=0,g=h.length;f<g;f++)c.graph.addEdge(h[f])}else\"object\"==typeof c?(c.graph=a,c=new sigma(c)):\"function\"==typeof c&&(d=c,c=null);return d?void d(c||a):a}var f,g,h,i;if(\"string\"==typeof a)gexf.fetch(a,e);else if(\"object\"==typeof a)return e(gexf.parse(a))}}.call(this);","<script>\n  import sigma from \"sigma.require.js\";\n  import \"plugins/sigma.parsers.gexf.min.js\";\n\n  let elem;\n\n  import { onMount } from \"svelte\";\n\n  sigma.classes.graph.addMethod(\"neighbors\", function(nodeId) {\n    var k,\n      neighbors = {},\n      index = this.allNeighborsIndex[nodeId] || {};\n\n    for (k in index) neighbors[k] = this.nodesIndex[k];\n\n    return neighbors;\n  });\n\n  onMount(() => {\n    sigma.parsers.gexf(\n      \"standard_graph.gexf\",\n\n      {\n        container: elem\n      },\n\n      function(s) {\n        s.graph.nodes().forEach(function(n) {\n          n.originalColor = n.color;\n        });\n        s.graph.edges().forEach(function(e) {\n          e.originalColor = e.color;\n        });\n\n        // When a node is clicked, we check for each node\n        // if it is a neighbor of the clicked one. If not,\n        // we set its color as grey, and else, it takes its\n        // original color.\n        // We do the same for the edges, and we only keep\n        // edges that have both extremities colored.\n        s.bind(\"clickNode\", function(e) {\n          var nodeId = e.data.node.id,\n            toKeep = s.graph.neighbors(nodeId);\n          toKeep[nodeId] = e.data.node;\n\n          s.graph.nodes().forEach(function(n) {\n            if (toKeep[n.id]) n.color = n.originalColor;\n            else n.color = \"#eee\";\n          });\n\n          s.graph.edges().forEach(function(e) {\n            if (toKeep[e.source] && toKeep[e.target]) e.color = e.originalColor;\n            else e.color = \"#eee\";\n          });\n\n          // Since the data has been modified, we need to\n          // call the refresh method to make the colors\n          // update effective.\n          s.refresh();\n        });\n\n        // When the stage is clicked, we just color each\n        // node and edge with its original color.\n        s.bind(\"clickStage\", function(e) {\n          s.graph.nodes().forEach(function(n) {\n            n.color = n.originalColor;\n          });\n\n          s.graph.edges().forEach(function(e) {\n            e.color = e.originalColor;\n          });\n\n          // Same as in the previous event:\n          s.refresh();\n        });\n      }\n    );\n  });\n</script>\n\n<style>\n  .sigmaElement {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div bind:this={elem} class=\"sigmaElement\" />\n","import App from './App.svelte'\n\nconst app = new App({\n  target: document.body\n})\n\nexport default app\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","insert","target","node","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","i","length","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","mount_component","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","d","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","context","Map","callbacks","ready","ret","rest","value","hydrate","nodes","Array","from","childNodes","children","l","c","intro","SvelteComponent","[object Object]","this","$destroy","type","index","indexOf","splice","undefined","__instances","window","addEventListener","key","hasOwnProperty","refresh","sigma","conf","o","id","classes","dispatcher","extend","_conf","HTMLElement","renderers","prototype","toString","call","renderer","container","defineProperty","settings","configurable","graph","get","cameras","_handler","e","k","data","dispatchEvent","bind","addRenderer","middlewares","read","addCamera","camera","self","arguments","quadtree","quad","edgequad","edgequadtree","renderCamera","renderersPerCamera","killCamera","v","killRenderer","cameraFrames","kill","getElementById","def","bounds","prefix","rescale","readPrefix","width","height","copy","skipIndexation","utils","getBoundaries","maxLevel","x","minX","y","minY","maxX","maxY","keys","process","console","log","render","force","requestAnimationFrame","instances","version","forceES5","global","conrad","_lastFrameTime","_isRunning","_jobs","_runningJobs","_sortedByPriorityJobs","_waitingJobs","_doneJobs","_noStart","_parameters","frameDuration","history","_handlers","_dispatch","events","j","i_end","j_end","event","eventName","eArray","isArray","split","handler","_executeFirstJob","test","pushed","time","__dateNow","job","shift","done","currentTime","weightTime","weight","averageTime","count","_activateJob","status","startTime","__clone","_loop","deadJob","after","_killJob","setTimeout","v1","found","end","_hasJob","__extend","res","item","result","__objectValues","Date","now","getTime","hasJob","addJob","_addJob","v2","killJob","killAll","jobs","a1","a2","getStats","stats","pattern","isPatternString","concat","RegExp","match","isRunning","clearHistory","_bind","unbind","module","exports","_root","_store","size","keyList","valueList","values","val","set","func","obj","enumerable","dateNow","pkg","pkgName","reduce","objName","floatColorCache","floatColor","original","r","g","slice","parseInt","charAt","color","zoomTo","ratio","animation","newRatio","coordinates","Math","max","min","duration","misc","easing","goTo","onComplete","getQuadraticControlPoint","x1","y1","x2","y2","cc","getPointOnQuadraticCurve","t","xi","yi","getPointOnBezierCurve","cx","cy","dx","dy","B0_t","B1_t","B2_t","B3_t","getSelfLoopControlPoints","getDistance","x0","y0","sqrt","getCircleIntersection","r0","r1","h","rx","ry","abs","xi_prime","yi_prime","isPointOnSegment","epsilon","distancePointToSegment","xx","yy","C","D","len_sq","param","isPointOnQuadraticCurve","cpx","cpy","dP1P2","old_dt","pt","dt","isPointOnBezierCurve","cpx1","cpy1","cpx2","cpy2","dP1CP1","getX","offsetX","layerX","clientX","getY","offsetY","layerY","clientY","getPixelRatio","screen","deviceXDPI","logicalXDPI","systemXDPI","devicePixelRatio","getWidth","w","ownerSVGElement","baseVal","getCenter","namespaceURI","getHeight","mouseCoords","ctrlKey","metaKey","altKey","shiftKey","getDelta","wheelDelta","detail","getOffset","dom","left","top","offsetTop","offsetLeft","offsetParent","doubleClick","handlers","clicks","_doubleClickHandler","doubleClickTimeout","unbindDoubleClick","removeEventListener","easings","linearNone","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","isWebGLSupported","canvas","WebGLRenderingContext","getContext","loadShader","gl","shaderSource","shaderType","error","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","loadProgram","shaders","attribs","loc","program","createProgram","attachShader","bindAttribLocation","locations","opt_attribs","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","matrices","translation","rotation","angle","m2","cos","sin","scale","multiply","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","getTextWidth","approximate","fontSize","text","measureText","setLevel","level","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","resetLevel","imgCache","drawImage","imgCrossOrigin","threshold","clipFn","image","url","ih","iw","clip","setAttribute","src","onload","Event","xratio","yratio","save","beginPath","arc","PI","closePath","restore","drawIcon","icon","font","fgColor","content","fontSizeRatio","round","fillStyle","textAlign","textBaseline","fillText","lastTime","vendors","cancelAnimationFrame","currTime","timeToCall","clearTimeout","Function","oThis","TypeError","fNOP","fBound","aArgs","fToBind","apply","clone","immutable","verbose","classPrefix","defaultNodeType","defaultEdgeType","defaultLabelColor","defaultEdgeColor","defaultNodeColor","defaultLabelSize","labelAlignment","edgeColor","minArrowSize","fontStyle","labelColor","labelSize","labelSizeRatio","labelThreshold","maxNodeLabelLineLength","webglOversamplingRatio","nodeBorderSize","defaultNodeBorderColor","hoverFont","singleHover","hoverFontStyle","labelHoverShadow","labelHoverShadowColor","nodeHoverColor","defaultNodeHoverColor","labelHoverBGColor","defaultHoverLabelBGColor","labelHoverColor","defaultLabelHoverColor","edgeHoverColor","edgeHoverSizeRatio","defaultEdgeHoverColor","edgeHoverExtremities","drawEdges","drawNodes","drawLabels","drawEdgeLabels","batchEdgesDrawing","hideEdgesOnMove","canvasEdgesBatchSize","webglEdgesBatchSize","approximateLabelWidth","edgesClippingWithNodes","autoCurveRatio","autoCurveSortByDirection","scalingMode","sideMargin","minEdgeSize","maxEdgeSize","minNodeSize","maxNodeSize","clickToFocus","touchEnabled","mouseEnabled","mouseWheelEnabled","doubleClickEnabled","eventsEnabled","zoomingRatio","doubleClickZoomingRatio","zoomMin","zoomMax","zoomOnLocation","mouseZoomDuration","doubleClickZoomDuration","mouseInertiaDuration","mouseInertiaRatio","touchInertiaDuration","touchInertiaRatio","doubleTapTimeout","dragTimeout","autoRescale","enableCamera","enableHovering","enableEdgeHovering","edgeHoverPrecision","rescaleIgnoreSize","skipErrors","nodeQuadtreeMaxLevel","edgeQuadtreeMaxLevel","nodesPowRatio","edgesPowRatio","animationsTime","n","getEvent","one","args","datas","embedObjects","_methods","_indexes","_initBindings","_methodBindings","_methodBeforeBindings","_defaultSettings","_defaultSettingsFunction","nodesArray","edgesArray","nodesIndex","edgesIndex","inNeighborsIndex","outNeighborsIndex","allNeighborsIndex","__bindGraphMethod","methodName","scope","addMethod","hasMethod","attach","before","bindings","attachBefore","addIndex","validNode","parseFloat","edge","source","validEdge","dropEdge","addNode","edges","addEdge","which","in","out","isAnimated","embedObject","isNaN","applyView","write","relCos","relSin","nodeRatio","pow","edgeRatio","xOffset","yOffset","graphPosition","vector","X","Y","cameraPosition","getMatrix","getRectangle","widthVect","heightVect","centerVect","marginX","marginY","_geom","pointToSquare","lineToSquare","quadraticCurveToSquare","cp","selfLoopToSquare","isAxisAligned","axisAlignedTopPoints","lowerLeftCoor","lowerRightCoor","llc","rectangleCorners","lrc","splitSquare","axis","c1","c2","projection","axisCollision","sc1","sc2","ci","p1","p2","maxc1","maxc2","minc1","collision","col","_quadIndexes","rectangle","quadCorners","indexes","_quadCollision","corners","_quadSubdivide","next","subw","subh","qx","qy","_quadTree","maxElements","_quadInsert","el","sizedPoint","elements","indexEdges","_tree","_cache","query","_enabled","_indexEdges","params","curvatureCoefficients","point","_quadRetrievePoint","quadBounds","xmp","ymp","_quadIndex","area","rect","collisionFunc","rectData","serialized","JSON","stringify","_quadRetrieveArea","els","elementsArr","captors","mouse","_startCameraX","_startCameraY","_lastCameraX","_lastCameraY","_startMouseX","_startMouseY","_isMouseDown","_isMoving","_hasDragged","_downStartTime","_movingTimeoutId","_self","_target","_camera","_settings","_moveHandler","pos","isMoving","preventDefault","returnValue","stopPropagation","_upHandler","_downHandler","_outHandler","eltFocused","blur","_clickHandler","focus","isDragging","_wheelHandler","touch","_startCameraAngle","_startCameraRatio","_startTouchX0","_startTouchY0","_startTouchX1","_startTouchY1","_startTouchAngle","_startTouchDistance","_touchMode","_doubleTap","_downTouches","position","offset","pageX","pageY","_handleStart","pos0","pos1","touches","atan2","_handleLeave","inertiaRatio","_handleMove","diff","start","dAngle","dRatio","newStageX","newStageY","newStageRatio","newStageAngle","contexts","domElements","nodesOnScreen","edgesOnScreen","conradId","initDOM","scene","labels","hover","bindEvents","drawHovers","resize","applyRenderers","ctx_infos","elementType","hidden","renderEdges","renderParams","batchSize","tempGCO","embedSettings","globalCompositeOperation","tag","style","appendChild","toLowerCase","oldWidth","oldHeight","pixelRatio","offsetWidth","offsetHeight","tagName","clearRect","captor","webgl","nodeFloatArrays","edgeFloatArrays","edgeIndicesArrays","array","Float32Array","POINTS","ATTRIBUTES","computeIndices","nodesGl","edgesGl","matrix","arr","indices","edgePrograms","initProgram","useProgram","scalingRatio","indicesData","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodePrograms","preserveDrawingBuffer","viewport","COLOR_BUFFER_BIT","svg","groups","edgelabels","hovers","measurementCanvas","freeStyle","bindDOMEvents","bindHovers","subrenderers","forceLabels","hideDOMElements","createElementNS","setAttributeNS","hide","hoveredNode","enter","leave","buffer","positionLocation","getAttribLocation","sizeLocation","colorLocation","angleLocation","resolutionLocation","getUniformLocation","matrixLocation","ratioLocation","scaleLocation","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","uniform2f","uniform1f","uniformMatrix3fv","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","drawArrays","TRIANGLES","vertexShader","fragmentShader","join","VERTEX_SHADER","FRAGMENT_SHADER","fast","positionLocation1","positionLocation2","thicknessLocation","minusLocation","matrixHalfPiLocation","matrixHalfPiMinusLocation","STATIC_DRAW","uniformMatrix2fv","lineWidth","LINES","arrow","targetSize","targetSizeLocation","delayLocation","headLocation","headPositionLocation","nodeRatioLocation","arrowHeadLocation","splitWord","word","maxLength","parts","substr","lastPartLen","infos","labelOffsetX","labelOffsetY","borderSize","alignment","maxLineLength","label","new_font","active","lines","words","lineLength","lineIndex","lineList","lineFull","getLines","baseX","baseY","labelWidth","moveTo","arcTo","lineTo","drawHoverBorder","strokeStyle","stroke","curve","sSize","sX","sY","tX","tY","bezierCurveTo","quadraticCurveTo","tSize","aSize","aX","aY","vX","vY","curvedArrow","edgehovers","hover_color","extremities","show","display","circle","line","path","fontColor","innerHTML","textContent","nodeCircle","group","writePrefix","margin","sizeMax","weightMax","rescaleSettings","validSettings","nodePosition","nodeSize","edgeSize","np","ns","es","doEdges","Infinity","_getID","anim","initialVal","coef","running","onNewFrame","frameId","mX","mY","getNodes","s","inserted","selected","modifiedX","modifiedY","getEdges","isCanvas","maxEpsilon","nodeIndex","insertEdge","bindCaptor","overNodes","overEdges","onMove","newOutNodes","newOverNodes","currentOverNodes","newOutEdges","newOverEdges","currentOverEdges","current","hovered","Element","domElement","attr","attrName","getAttributeNS","class","isNode","isEdge","isHover","click","toElement","el_svg","fromElement","originalTarget","draw","model","nodeListEach","getAttribute","title","nodeListToArray","defaultValue","f","getElementsByTagName","nodeListToHash","namedNodeMapToObject","attributes","enforceType","root","meta","getModelTags","hasViz","mode","defaultEdgetype","lastmodifieddate","viz","getFirstElementByTagNS","getRGB","shape","thickness","XMLHttpRequest","ActiveXObject","overrideMimeType","responseXML","DOMParser","parseFromString","responseText","open","onreadystatechange","readyState","send","nodeName","getElementsByTagNameNS","gexf","parse","fetch","parsers","latitude","lat","longitude","lng","direction","attribute","removeAttribute","elem","nodeId","neighbors","originalColor","toKeep","outros","body"],"mappings":"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"}